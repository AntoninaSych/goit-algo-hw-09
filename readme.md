
Час виконання жадібного алгоритму становить лише 3.0994415283203125e-06 секунд (або приблизно 3 мікросекунди), тоді як час виконання алгоритму динамічного програмування складає 0.000225067138671875 секунд (або приблизно 0.225 секунди). Жадібний алгоритм виявився значно швидшим за алгоритм динамічного програмування у цьому конкретному випадку. Проте варто зауважити, що швидкість виконання може змінюватися в залежності від конкретних обставин та об'єму вхідних даних.

Незважаючи на те, що жадібний алгоритм працює швидше, алгоритм динамічного програмування зазвичай надає оптимальний результат для будь-якої суми, оскільки знаходить мінімальну кількість монет для кожної суми решти. При великих сумах жадібний алгоритм може давати неоптимальний результат, оскільки може обрати недостатню кількість монет більшого номіналу. У таких випадках алгоритм динамічного програмування виявляється більш ефективним, оскільки забезпечує мінімальну кількість монет для будь-якої суми.

Отже, вибір між жадібним алгоритмом та алгоритмом динамічного програмування залежить від конкретної задачі та обсягу вхідних даних. Якщо потрібна швидкість, а результат може бути невеликими неточностями, можна використовувати жадібний алгоритм. У разі потреби у точності та оптимальності результату, особливо при роботі з великими сумами, краще скористатися алгоритмом динамічного програмування.## Висновки

Порівнявши ефективність жадібного алгоритму та алгоритму динамічного програмування для задачі розбиття суми на монети, можемо зробити наступні висновки:

1. **Жадібний алгоритм** видає результат швидше за алгоритм динамічного програмування, оскільки не потребує обчислення всіх можливих комбінацій для знаходження мінімальної кількості монет. Він працює ефективно при малих сумах, коли доступні номінали монет добре підходять під суму решти.

2. **Алгоритм динамічного програмування** зазвичай має значно більшу обчислювальну складність через необхідність обчислення всіх можливих комбінацій. Проте він надає оптимальний результат для будь-якої суми, оскільки знаходить мінімальну кількість монет для кожної суми решти.

3. При великих сумах **жадібний алгоритм** може давати неоптимальний результат, оскільки може обрати недостатню кількість монет більшого номіналу. У цих випадках **алгоритм динамічного програмування** виявляється більш ефективним, оскільки забезпечує мінімальну кількість монет для будь-якої суми.

Отже, вибір між жадібним алгоритмом та алгоритмом динамічного програмування залежить від конкретної задачі та обсягу вхідних даних.


## Висновки

Порівнявши ефективність жадібного алгоритму та алгоритму динамічного програмування для задачі розбиття суми на монети, можемо зробити наступні висновки:

1. **Жадібний алгоритм** видає результат швидше за алгоритм динамічного програмування, оскільки не потребує обчислення всіх можливих комбінацій для знаходження мінімальної кількості монет. Він працює ефективно при малих сумах, коли доступні номінали монет добре підходять під суму решти.

2. **Алгоритм динамічного програмування** зазвичай має значно більшу обчислювальну складність через необхідність обчислення всіх можливих комбінацій. Проте він надає оптимальний результат для будь-якої суми, оскільки знаходить мінімальну кількість монет для кожної суми решти.

3. При великих сумах **жадібний алгоритм** може давати неоптимальний результат, оскільки може обрати недостатню кількість монет більшого номіналу. У цих випадках **алгоритм динамічного програмування** виявляється більш ефективним, оскільки забезпечує мінімальну кількість монет для будь-якої суми.

Отже, вибір між жадібним алгоритмом та алгоритмом динамічного програмування залежить від конкретної задачі та обсягу вхідних даних.
